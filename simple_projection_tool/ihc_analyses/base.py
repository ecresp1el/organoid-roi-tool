"""Reusable scaffolding for immunohistochemistry projection analyses.

The goal of this module is to give every downstream biological question a
predictable place to put code.  Each analysis object that works with the TIFF
projections generated by :mod:`simple_channel_projections` should inherit from
:class:`ProjectionAnalysis` and fill in the hooks for loading data, processing
it, and producing figures/tables.  Scientists can therefore copy an existing
analysis, change only the biological logic, and immediately gain a working
pipeline that saves intermediate files to disk.
"""

from __future__ import annotations

import abc
from pathlib import Path
from typing import Dict, Optional, Sequence

import pandas as pd

try:  # Matplotlib is optional for analyses that never create figures.
    from matplotlib.figure import Figure
except Exception:  # pragma: no cover - fallback when matplotlib is unavailable
    Figure = None  # type: ignore[misc,assignment]


class ProjectionAnalysis(abc.ABC):
    """Template for building reproducible analysis pipelines.

    Subclasses are expected to implement two mandatory steps:

    ``import_data``
        Locate the exported TIFFs and return a manifest (``pandas.DataFrame``)
        describing what will be processed.  The base class stores this manifest
        for later saving.

    ``process_data``
        Take the manifest, load each file, and calculate the per-image
        statistics of interest.  The returned ``DataFrame`` is likewise stored.

    Optional hooks such as :meth:`run_statistics` and :meth:`generate_plots`
    can be overridden when an analysis needs them.  The :meth:`run` method calls
    each stage in order so a scientist can execute the entire pipeline with a
    single command.  Any tables or figures produced by the analysis are saved
    beneath ``<output_dir>/analysis_pipeline`` so collaborators always know
    where to look for derived artefacts.
    """

    #: Human readable identifier used for folder names and command line choices.
    name: str = "projection_analysis"

    def __init__(
        self,
        base_path: Path | str,
        *,
        projection_dir_name: str = "simple_projections",
        output_dir: Optional[Path | str] = None,
    ) -> None:
        """Set up common paths used by the analysis.

        Parameters
        ----------
        base_path:
            Root directory that contains the exported projection folders.  The
            default command line wrapper points this to the project folder on
            the shared drive, but it can be overridden for testing.
        projection_dir_name:
            Name of the directory (inside ``base_path``) that holds the outputs
            of :mod:`simple_channel_projections`.  Keeping this configurable
            allows future analyses to point at alternative export folders.
        output_dir:
            Destination for CSV summaries, plots, and any other artefacts.  If
            omitted we create ``<base_path>/analysis_results/<analysis-name>``
            so each biological question keeps its deliverables in one place.  A
            nested ``analysis_pipeline`` directory is created automatically to
            store ``data/`` (CSV tables) and ``figures/`` (plots, typically SVG
            and PNG) associated with the analysis.
        """

        self.base_path = Path(base_path).expanduser().resolve()
        self.projection_dir_name = projection_dir_name
        self.projection_root = self.base_path / self.projection_dir_name
        self.output_dir = (
            Path(output_dir).expanduser().resolve()
            if output_dir is not None
            else self.base_path / "analysis_results" / self.name
        )

        # Derived outputs (tables, plots) are stored beneath ``analysis_pipeline``
        # to make it obvious that they were generated by a downstream analysis
        # stage rather than the initial projection export.
        self.pipeline_dir = self.output_dir / "analysis_pipeline"
        self.data_dir = self.pipeline_dir / "data"
        self.figures_dir = self.pipeline_dir / "figures"

        # Subclasses can register additional tables (e.g. statistics summaries)
        # for saving once the pipeline finishes running.
        self.additional_tables: Dict[str, pd.DataFrame] = {}

        # The manifest lists every file we plan to inspect.  ``results`` stores
        # the processed measurements calculated from those files.  Subclasses
        # fill these with pandas DataFrames so downstream steps (saving, plots)
        # can reuse them without needing to re-run heavy computations.
        self.manifest: Optional[pd.DataFrame] = None
        self.results: Optional[pd.DataFrame] = None

    # ------------------------------------------------------------------
    # Pipeline orchestration
    # ------------------------------------------------------------------
    def run(self) -> None:
        """Execute the end-to-end pipeline for the analysis.

        The default implementation is intentionally simple: each stage is
        called in sequence and the intermediate results are stored as object
        attributes.  Scientists can subclass the analysis and override any of
        the hooks for additional behaviour (e.g. emailing collaborators after
        the results are exported).
        """

        self.manifest = self.import_data()
        self.results = self.process_data(self.manifest)
        self.run_statistics()
        self.generate_plots()
        self.save_outputs()
        self.export_results()

    # ------------------------------------------------------------------
    # Mandatory steps
    # ------------------------------------------------------------------
    @abc.abstractmethod
    def import_data(self) -> pd.DataFrame:
        """Discover and catalogue the projection files used by the analysis."""

    @abc.abstractmethod
    def process_data(self, manifest: pd.DataFrame) -> pd.DataFrame:
        """Perform the core numerical processing for the analysis."""

    # ------------------------------------------------------------------
    # Optional steps for subclasses to extend
    # ------------------------------------------------------------------
    def run_statistics(self) -> None:
        """Run statistical comparisons across processed results.

        The default implementation is a no-op and can be overridden by
        subclasses that need formal statistical tests.
        """

    def generate_plots(self) -> None:
        """Produce figures summarising the analysis.

        The default implementation is a no-op, allowing subclasses to defer plot
        creation until required.
        """

    def save_outputs(self) -> None:
        """Persist intermediate artefacts such as CSV files.

        The default implementation now funnels everything into
        ``<output_dir>/analysis_pipeline`` so scientists can immediately locate
        the derivative data generated by an analysis (as opposed to the raw
        projection exports).
        """

        self.pipeline_dir.mkdir(parents=True, exist_ok=True)
        self.data_dir.mkdir(parents=True, exist_ok=True)
        if self.manifest is not None:
            manifest_path = self.data_dir / "manifest.csv"
            self.manifest.to_csv(manifest_path, index=False)
        if self.results is not None:
            results_path = self.data_dir / "results.csv"
            self.results.to_csv(results_path, index=False)
        for filename, table in self.additional_tables.items():
            target = filename if filename.lower().endswith(".csv") else f"{filename}.csv"
            table_path = self.data_dir / target
            table.to_csv(table_path, index=False)

    # ------------------------------------------------------------------
    # Convenience helpers for subclasses
    # ------------------------------------------------------------------
    def register_table(self, filename: str, table: pd.DataFrame) -> None:
        """Queue an additional table to be written by :meth:`save_outputs`."""

        if not filename:
            raise ValueError("filename must be a non-empty string")
        self.additional_tables[filename] = table

    def save_figure(
        self,
        figure: "Figure",
        stem: str,
        *,
        formats: Sequence[str] = ("svg", "png"),
        dpi: int = 300,
        metadata: Optional[Dict[str, str]] = None,
    ) -> None:
        """Persist a Matplotlib figure in the analysis figures directory."""

        if Figure is None:
            raise RuntimeError(
                "matplotlib is required to save figures but could not be imported."
            )
        if not stem:
            raise ValueError("stem must be a non-empty string")

        self.figures_dir.mkdir(parents=True, exist_ok=True)
        for ext in formats:
            ext = ext.lower().lstrip(".")
            output_path = self.figures_dir / f"{stem}.{ext}"
            save_kwargs = {
                "format": ext,
                "dpi": dpi,
                "bbox_inches": "tight",
            }
            if metadata:
                save_kwargs["metadata"] = metadata
            figure.savefig(output_path, **save_kwargs)

    def export_results(self) -> None:
        """Hook for exporting artefacts to external systems.

        Subclasses can override this to push data to collaborators, shared
        drives, etc. The default implementation intentionally does nothing.
        """

